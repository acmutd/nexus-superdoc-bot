from googledoc.googledoc import GoogleDocsEditor

#from docling.datamodel.pipeline_options import PdfPipelineOptions
#from docling.document_converter import DocumentConverter, PdfFormatOption
#from docling.datamodel.base_models import InputFormat
#from docling.datamodel.base_models import DocumentStream
import os.path

#from chunking.doc_chunking import DocSemChunker, cosine_similarity
#from langchain_core.documents import Document

#from vectordb.vector_db_manager import VectorDBManager, Pinecone
import numpy as np



from langchain_openai import OpenAIEmbeddings,ChatOpenAI

from vectordb.vector_db_manager import VectorDBManager
from pinecone import Pinecone, IndexModel, ServerlessSpec



from pdf_pipeline.parse import EmbedTreeNode, GdocTreeNode, pdf_to_syntree, stree_to_etree
from io import BytesIO

from dotenv import load_dotenv
import os
import time
load_dotenv()



class superdoc():
    
    #Clean up init
    def __init__(self,DOCUMENT_ID:str|None,COURSE_ID:str,index_name='sdtest1'):
        self.DOCUMENT_ID = DOCUMENT_ID
        self.COURSE_ID = COURSE_ID
        self.docs_editor = GoogleDocsEditor()
        if DOCUMENT_ID is None: 
            self.DOCUMENT_ID = self.docs_editor.create_google_doc(name=COURSE_ID).get('documentId')

        self.db = VectorDBManager(pc=Pinecone(os.environ.get("PINECONE_API_KEY")))
        self.db.initVectorStore(index_name=index_name, embedding=OpenAIEmbeddings(api_key=os.getenv("OPENAI_API_KEY")))
        
        self.docs_editor.get_document_structure(document_id=self.DOCUMENT_ID)
        self.emb_model =OpenAIEmbeddings(api_key=os.getenv("OPENAI_API_KEY")) 
    
    def merge_pdf_hierarchical(self, stream: BytesIO):
        """
        New tree-based merge functionality that respects document hierarchy 
        and handles custom heading injection.
        """
        print(f"--- Starting Hierarchical Merge for Doc: {self.DOCUMENT_ID} ---")
        
        # 1. Convert PDF to Syntax Tree (Markdown-it structure)
        # Note: Ensure pdf_to_syntree is available in your scope
        start_time = time.perf_counter()
        synt_tree = pdf_to_syntree(stream=stream) 
        
        # 2. Build the Semantic EmbedTree and calculate embeddings
        # This populates node.emb and node.mean_emb (as native Python lists)
        root = stree_to_etree(stree=synt_tree, emb_model=self.emb_model)
        
        # 3. Fetch existing headings from Pinecone for this course/doc
        # This allows the tree to find where this new PDF "fits" into existing topics
        existing_headings = self.db.get_all_headings_for_doc(
            course_id=self.COURSE_ID, 
            superdoc_id=self.DOCUMENT_ID
        )
        
        # 4. Inject Custom Headings and detect "Stragglers"
        # new_cust_nodes: Brand new headings generated by LLM for orphaned content
        # all_cust_nodes: Total set of custom nodes (existing + new) to be rendered
        new_cust_nodes, all_cust_nodes = root.insert_custom_headings(headings=existing_headings)
        
        # 5. Sync new structural nodes to Vector DB
        # We only append the NEWLY generated headings so we don't duplicate existing ones
        if new_cust_nodes:
            print(f"Syncing {len(new_cust_nodes)} new custom headings to Pinecone...")
            self.db.append_documents(
                e_branches=new_cust_nodes, 
                course_id=self.COURSE_ID, 
                superdoc_id=self.DOCUMENT_ID
            )

        # 6. Render to Google Docs
        # This uses the specialized hierarchical renderer
        print(f"Rendering {len(all_cust_nodes)} custom branches to Google Doc...")
        render_start = time.perf_counter()
        
        # This method handles named ranges and structural formatting
        self.docs_editor.render_etree_custom_nodes(
            superdoc_id=self.DOCUMENT_ID, 
            all_cust_nodes=all_cust_nodes
        )
        
        end_time = time.perf_counter()
        print(f"Total Merge Process completed in: {(end_time - start_time):.2f}s")
        print(f"Google Doc Render took: {(end_time - render_start):.2f}s")
    '''
    def merge_pdf(self, stream:DocumentStream):
        # Convert the provided PDF file (requires file path string)
        start_time = time.perf_counter()
        pdf = self.converter.convert(stream).document 
        end_time = time.perf_counter()
        print(f"Converting Document time:{(end_time-start_time):.4f} seconds")

        start_time = time.perf_counter()
        chunk_iter = list(self.chunker.chunk(dl_doc=pdf,doc_name=self.DOCUMENT_ID))
        end_time = time.perf_counter() 
        print(f"Embedding document time:{(end_time-start_time):.4f} seconds")

        start_time = time.perf_counter() 
        chunk_iter = self.db.modify_doc_heading(documents=chunk_iter,superdoc_id=self.DOCUMENT_ID,course_id=self.COURSE_ID)
        end_time = time.perf_counter()
        print(f"VectorDB comparisons time:{(end_time-start_time):.4f} seconds")

        start_time = time.perf_counter()
        #may need this everytime I call this method depending on of there are gdoc manipulations before this method
        self.docs_editor.get_document_structure(document_id=self.DOCUMENT_ID)
        self.docs_editor.mutate_named_ranges(document_id=self.DOCUMENT_ID)
        self.docs_editor.insert_text(document_id=self.DOCUMENT_ID, chunk_docs=chunk_iter)
        end_time = time.perf_counter() 
        print(f"Google doc editing:{(end_time-start_time):.4f} seconds")

    '''
    def delete_heading(self,old_heading:str): 
        self.docs_editor.delete_heading(old_heading=old_heading)
        self.db.remove_vectordb_heading(heading=old_heading,course_id=self.COURSE_ID,superdoc_id=self.DOCUMENT_ID)
    
    def create_heading(self,new_heading:str):
        self.docs_editor.create_heading(new_heading=new_heading)
        self.db.create_vectordb_heading(heading_text=new_heading,course_id=self.COURSE_ID,superdoc_id=self.DOCUMENT_ID)
    '''Updates old_heading in both google docs and vectorDb'''
    def update_heading(self,old_heading:str,new_heading:str):
        #update googledoc heading named range
        self.docs_editor.update_heading(old_heading=old_heading,new_heading=new_heading)
        self.db.replace_vectordb_heading_with_text(old_heading=old_heading,new_heading_text=new_heading,course_id=self.COURSE_ID,superdoc_id=self.DOCUMENT_ID)

    def get_docids(self,course_id:str): 
        return self.docs_editor.get_idstore_docids(courseid=course_id)
            
        
        
    



def insert_text_ex(): 
     # Initialize the editorpinecone_api_key = os.environ.get("PINECONE_API_KEY")
    pinecone_api_key = os.environ.get("PINECONE_API_KEY")
    print(f"Start of VectorDBManager init")
    db = VectorDBManager(pc=Pinecone(pinecone_api_key))
    db.initVectorStore(index_name="sdtest1", embedding=OpenAIEmbeddings(api_key=os.getenv("OPENAI_API_KEY")))
    print(f"Start of pdf conversion")
    docs_editor = GoogleDocsEditor()
    
    converter = DocumentConverter()
    doc = converter.convert("./files/ResearchPaperTurnIn.pdf").document 
    chunker = DocSemChunker() 
    print("Starting chuking")
    chunk_iter = list(chunker.chunk(dl_doc=doc,doc_name="rpaper"))
    # Your Google Docs document ID (om the URL)
    chunk_iter = db.modify_doc_heading(documents=chunk_iter,superdoc_id="rpaper",course_id="RHET1302")
    DOCUMENT_ID = '1zjQClSEUE587kPrupY5fplFtUcB3OGEj5mKhplmiFxM'
    
    # Example 1: Append to the very end
    docs_editor.get_document_structure(document_id=DOCUMENT_ID)
   # print(f"Doc structure:{docs_editor.doc}")
    #print(docs_editor.find_insertion_point("stuff"))
    #print("Appending to end of document...")
    docs_editor.insert_text(document_id=DOCUMENT_ID, chunk_docs=chunk_iter)
    
    
if __name__ == '__main__': 
    sd = superdoc(DOCUMENT_ID='1zjQClSEUE587kPrupY5fplFtUcB3OGEj5mKhplmiFxM',COURSE_ID="RHET1302")
    #sd.merge_pdf()
   # sd.update_heading(old_heading="Introduction",new_heading="GoofyGoober")
    #sd.create_heading(new_heading="Trump giving Kirk to Bubba")
    sd.delete_heading(old_heading="Trump giving Kirk to Bubba")